<!DOCTYPE html>
<% provide(:title, "Lua") %>

<div class="sidenav">
  <a href="<%= static_pages_work_url %>">About</a>
  <a href="<%= static_pages_ruby_url %>">Ruby</a>
  <a class="active" href="<%= static_pages_lua_url %>">Lua</a>
  <a href="<%= static_pages_glsl_url %>">GLSL</a>
  <a href="<%= static_pages_contact_url %>">Contact</a>
</div>

<div class="main">
  <h3>Lua + LÖVE</h3>
</div>

<div class="mainbody">
  <h3>ScarletLib</h3>
  <a>2018-2019</a>
  <a href="https://github.com/jmackellar/ScarletLib">Github</a></br></br>
  <a>A gameState and UI library written for LÖVE 0.10.x.  gameStates are loaded as seperate Lua files and hook into the
  existing LÖVE callbacks allowing for greater project organization.  The UI library has support for frames, images, 
  buttons, progress bars, text input and more.  UI elements can be created, modified, or deleted individualy or through
  groups, along with support for batched updating and deletion.  The library runs stable with upwards of 1000 elements
  updated and rendered to the screen per frame.</a></br></br>
  <a>gameState Usage</a>
  <pre class="prettyprint">
    --- main.lua
    --- Example stateGame usage 
    
    local ScarletLib = require 'scarletLib'
    require 'menu'  --- seperate state game file
    require 'game'  --- seperate state game file 
    
    function love.load()
      --- Register our two game state files
      ScarletLib.gamestate.registerGameState('menu')
      ScarletLib.gamestate.registerGameState('game')
      --- Switch to a new game state.  The first time a 
      --- state is switched to state.load callback is 
      --- executed if state.load exists.  
      --- state.enter is also executed if the callback 
      --- exists in the state file.
      ScarletLib.gamestate.switchGameState('menu')
    end
    
    --- Example of user defined callback to a 
    --- gameState file
    function love.update(dt)
    	if ScarletLib.gamestate.getGameState().update then
    		ScarletLib.gamestate.getGameState().update(dt)
    	end
    end
  </pre>
  <pre class="prettyprint">
    --- menu.lua 
    --- Example stateGame usage 
    local menu = { } 
    
    --- Called the first time the gameState has 
    --- been entered 
    function menu.load()
    
    end 
    
    --- Called every time the gameState is switched to
    function menu.enter()
    
    end 
    
    --- User defined callback 
    function menu.update(dt)
    
    end 
    
    --- Return the local state to the state machine
    return menu
  </pre>
  <a>UI Usage</a>
  <pre class="prettyprint">
    --- UI Library example 
    
    --- Adding a frame 
    scarletLib.layout.addFrame({
      name = 'frame1',
      group = 'uigroup',
      x = 0,
      y = 0,
      width = 500,
      height = 500,
      z = 0,
      style = 1,
  	})
  	
    --- Adding a button 
    scarletLib.layout.addButton({
    	name = 'button1',
    	group = 'uigroup',
    	x = 15,
    	y = 15,
    	z = 1,
    	sx = 3,
    	sy = 3,
    	img = love.graphics.newImage("/path/to/image"),
    	hilightable = false,
    	hilighttext = 'Press Me!',
    	hilightfont = 'font1',
    	buttonpressed = function (self)
    	                  --- Some action
    	                end
    })
    
    --- Change frame1s width by 100 pixels 
    scarletLib.layout.changeElement('frame1', 'width', 100, true) 
    --- Set the x position of both elements to 100 
    scarletLib.layout.changeElementGroup('uigroup', 'x', 100, false)
    --- Flag group to be deleted and then process the 
    --- batch deletion
    scarletLib.layout.deleteByGroup('uigroup')
    scarletLib.layout.deleteFlaggedGroups()
  </pre>
  <h3>Rogue</h3>
  <a>2020</a>
  <a href="https://www.github.com/jmackellar/RogueGame">Github</a></br>
  <a href="https://www.youtube.com/watch?v=b14OiCfK9Nc">Video 1</a>
  <a href="https://www.youtube.com/watch?v=wVKR3ss5EGM&feature=youtu.be">Video 2</a></br>
  <a>A turn based RPG that features an infinitely generated world, open world faction system, and emergent gameplay.
  The game world is generated into chunks of biomes through perlin noise, with the individual world tiles using a combination
  of BSP generation and walker algorothims.  A generalized AI system combined with the faction system allows for creatures
  to pick and choose their targets between the player and NPCs allowing for a world that feels open and alive.</a>
  <h3>Heat Death</h3>
  <a>2019-2020</a>
  <a href="https://www.github.com/jmackellar/HeatDeath">Github</a></br>
  <a>An action game set in space.  The player object and enemy objects are identical, meaning the enemies may use any attack, item,
  or spell that the player may and use, and vice versa.  The creature objects are controlled through a state and animation system 
  where each part of the body is tracked seperately and moved accordingly to allow for different states to be combined with different
  game items.</a>
  <h3>Immorlands</h3>
  <a>2018</a>
  <a href="https://www.github.com/jmackellar/Immorlands">Github</a></br>
  <a>An action RPG about exploring a dungeon underneath a cave.  The object state system, UI framework, and dynamic lighting effects 
  used in Heat Death were originally written for this project before being updated and improved upon.</a>
</div>